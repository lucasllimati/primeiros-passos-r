---
title: "Importando dados para o `R`"
subtitle: 'Live 03 - youtube.com/analisemacro'
author: "Vítor Wilher"
output: 
  beamer_presentation:
    #theme: "Boadilla"
    slide_level: 2
    fig_width: 8
    fig_height: 4
    fig_caption: true
    citation_package: 'natbib'
    includes:
      in_header: beamer.txt
      before_body: toc.txt
bibliography: 'references.bib'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

```



# Introdução
## Introdução

Em qualquer projeto de *análise de dados*, é comum que os dados estejam dispostos em arquivos com outras extensões. Assim, a pergunta imediata é:  como inseri-los no R?^[Essa seção está baseada em @r4ds.] Para isso, vamos mostrar nessa `Live` um pouco do que vemos no nosso `Curso de R para Análise de Dados`, sobre importação de dados para o R. Para começar, vamos carregar os pacotes `tidyverse`, como abaixo:

```{r, echo=T, eval=T, results='asis', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

library(tidyverse)
```

## Introdução 

Vamos começar pelo pacote `readr`, que lida com arquivos do tipo `csv`. As funções mais básicas desse pacote são:

* ``read_csv()``lê arquivos com separação com vírgulas ``,``.  
* ``read_csv2()`` lê arquivos separados com ``;``. 
* ``read_delim()`` lê arquivos com qualquer tipo de separação.
* ``read_fwf()`` lê arquivos com distância fixa. 
* ``read_table()`` faz isso com arquivos separados por espaços em braco - muito comum para bases disponibilizadas em extensão ``.txt``.
* ``read_log()`` lê arquivos em estilo Apache de logs

# A função `read_csv()`
## A função `read_csv()`

Abaixo, vemos um exemplo de utilizaçaõ da função `read_csv()`.

```{r, echo=T, eval=T, results='asis', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

heights <- read_csv("heights.csv")

```

## A função `read_csv()`

Se você colocar o objeto `heights` no Console, verá que o output dele é o de um `tibble`...

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

heights

```

## Usando argumentos da função `read_csv()`

Lembre-se que você sempre poderá utilizar `?read_csv` para consultar os argumentos da função - ou de qualquer função, diga-se, do R! Vamos usar abaixo alguns dos mais comuns.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

sidra = read_csv2('sidra.csv', skip=5,
                  col_names = c('mes', 'vendas', 'vendas_sa', 
                                'receita', 'receita_sa'),
                  col_types = 
                     cols(
                       mes = col_date(format='%d/%m/%Y'),
                       vendas = col_double(),
                       vendas_sa = col_double(),
                       receita = col_double(),
                       receita_sa = col_double()),
                  locale=locale(decimal_mark = ','))

```

# Strings
## Strings

Vamos agora ver como analisar vetores que contenham caracteres ou *strings*. Para isso, podemos utilizar a função `parse_character`. O problema com *strings* é que existem várias formas de representá-los. Para entender melhor, vamos começar com o exemplo abaixo.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

charToRaw('Seção')

```

## Strings

Cada número hexadecimal representa um *byte* de informação: 53 é o S. A relação entre o número hexadecimal e o caractere é chamado de `encoding`. O problema é quando o idioma não é o inglês, como no nosso caso. O pacote `readr` irá sempre assumir como *default* que o arquivo está com *encoding* **UTF-8** e acabará lendo o vetor que contenha caracteres especiais de forma errada. Para resolver isso, podemos fazer como no código abaixo.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

parse_character('Seção', locale = locale(encoding = 'Latin1'))

```

## Strings

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

subitem = read_csv2('subitem.csv')
subitem
```

## Strings

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

subitem = read_csv2('subitem.csv', 
                    locale = locale(encoding='Latin1'))

subitem
```


# Analisando um arquivo
## Analisando um arquivo

`readr` usa uma heurística para descobrir o tipo de cada coluna: lê as primeiras 1000 linhas e usa algumas heurísticas (moderadamente conservadoras) para descobrir o tipo de cada coluna. Você pode emular esse processo com um vetor de caracteres usando `guess_parser()`, que retorna a melhor estimativa de `readr` e `parse_guess()`, que usa essa suposição para analisar a coluna:

## Analisando um arquivo

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

guess_parser("2010-10-01")
guess_parser("15:01")
guess_parser(c("TRUE", "FALSE"))
guess_parser(c("1", "5", "9"))
guess_parser(c("12,352,561"))
str(parse_guess("2010-10-10"))

```

## Analisando um arquivo

A heurística tenta cada um dos seguintes tipos, parando quando encontra uma correspondência:

- lógico: contém apenas “F”, “T”, “FALSE” ou “TRUE”.
- integer: contém apenas caracteres numéricos (e -).
- double: contém apenas duplas válidas (incluindo números como 4.5e-5).
- number: contém duplas válidas com a marca de agrupamento dentro.
- time: corresponde ao time_format padrão.
- date: corresponde ao padrão date_format.
- data e hora: qualquer data ISO8601.

## Analisando um arquivo

Esses padrões nem sempre funcionam para arquivos maiores. Existem dois problemas básicos:

- As primeiras mil linhas podem ser um caso especial, e o readr adivinha um tipo que não é suficientemente geral. Por exemplo, você pode ter uma coluna de duplas que contenha apenas inteiros nas primeiras 1000 linhas.

- A coluna pode conter muitos valores ausentes. Se as primeiras 1000 linhas contiverem apenas `NAs`, o readr irá adivinhar que é um vetor de caracteres, enquanto você provavelmente desejará analisá-lo como algo mais específico.

# Arquivos txt
## Arquivos txt


```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

doc.text <- readLines('comunicado226.txt')

```

# Arquivos xlsx
## Arquivos xlsx

Anteriormente, vimos em detalhes como é possível analisar um arquivo através do pacote `readr`. Fizemos isso porque ela representa a ideia geral de como os pacotes `tidyverse` fazem a importação de dados para o R. 

\bigskip

Já aqui, vamos ver um pouco do pacote `readxl`, para importar arquivos do tipo `xls` e `xlsx`. 

# A função `read_excel`
## A função `read_excel`

A função `readxl::read_excel()` irá adivinhar os tipos de coluna, por padrão, ou você pode fornecê-los explicitamente através do argumento `col_types`.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

library(readxl)
## Importar uma planilha da internet
url = 'https://analisemacro.com.br/download/27398/'
download.file(url, 'resultado.xlsx', mode='wb')
data_stn = read_excel("resultado.xlsx", sheet='1.1',
                      range='B5:JV79', col_types = 'numeric')


```

# Arquivos zipados
## Arquivos zipados

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

temp <- tempfile()
download.file("http://www.bcb.gov.br/ftp/notaecon/Divggnp.zip",temp)
datazip <- unzip(temp, files='Divggnp.xls')


```

## Arquivos zipados

```{r, echo=T, results='asis', fig.width=10, fig.height=5, fig.align='center', out.width=".9\\linewidth", warning=FALSE, message=FALSE, size='footnotesize'}

dados_covid <- vroom::vroom("https://data.brasil.io/dataset/covid19/caso_full.csv.gz")

```

