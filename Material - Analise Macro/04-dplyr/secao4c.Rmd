---
title: "O pacote `dplyr`"
#subtitle: "Seção 4c - O pacote ``dplyr``"
author: "Vítor Wilher"
output: 
  beamer_presentation:
    #theme: "Boadilla"
    slide_level: 2
    fig_width: 8
    fig_height: 4
    fig_caption: true
    citation_package: 'natbib'
    includes:
      in_header: beamer.txt
      before_body: toc.txt
bibliography: 'references.bib'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

```



# Introdução
## Introdução

Parte significante do trabalho de análise de dados envolve trabalhar bases brutas e transformá-las em formatos mais interessantes. O R já vem com ferramentas para isso, mas elas não são tão eficientes quanto as disponibilizadas no pacote ``dplyr``. A ideia do ``dplyr`` é oferecer uma _gramática dos dados_, uma maneira concisa e clara de manipulá-los. Ele é parte do mais amplo ``tidyverse``, do qual também faz parte o ``ggplot2``. 

\bigskip

Como temos visto, o ``tidyverse`` é uma coleção de pacotes com ferramentas úteis para tratar, transformar, analisar e visualizar dados, muitos com uma filosofia comum. O ``dplyr`` é um dos pacotes mais populares do ``tidyverse`` e podemos carrega-lo sozinho ou com o resto dos pacotes.^[Essa parte do curso é baseada em @r4ds.]

# Carregando o pacote e _overwriting_
## Carregando o pacote e _overwriting_

Vamos carregar uma base de dados com vôos de Nova Iorque e o pacote ``dplyr`` (carregando junto o ``tidyverse``). Caso você não tenha algum dos pacotes ainda, é só rodar o código ``install.packages("nome do pacote")`` que o R faz isso por você. Para carregarmos os pacotes, basta usar a função ``library()``

```{r, echo=T, eval=T, results='asis', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

library(nycflights13)
library(tidyverse)
```

Observe que o ``dplyr`` tem conflitos com R base, no sentido de que duas funções que já existem no pacote ``stats``, que vem pré-carregado no R, são trocadas para as que o ``dplyr`` provê com o mesmo nome, são ``lag()`` e ``filter()``. Caso você queira usar uma delas na versão base, vai precisar especificar que é do pacote ``stats`` escrevendo: ``stats::lag()`` e ``stats::filter()``.

# Explorando dados
## Explorando dados

``flights`` vai carregar a base com os vôos:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

flights

```

Ao rodarmos uma linha de código com um objeto de classe ``data.frame``, normalmente temos de volta do R um resumo do objeto. Para ve-lo inteiro, use a função ``View()`` - atente para a letra maiúscula. 

# Básico do ``dplyr`` e de lógica
## Básico do ``dplyr`` e de lógica

``filter()`` te permite selecionar subconjuntos dos seus dados baseado em seus valores. O primeiro argumento é _sempre_ um objeto ``data.frame``, os subsequentes são argumentos lógicos que selecionem o que você quer:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
filter(flights, month == 1, day == 1)
```

## Básico do ``dplyr`` e de lógica

Observe que a saída dessa função é um objeto ``data.frame`` e o R entendeu como se tivéssemos escrito o nome desse objeto. Para armazena-lo precisamos fazer como sempre:

```{r, echo=T, eval=T, results='asis', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
dados.filtrados <- filter(flights, month == 1, day == 1)
```

É especialmente importante tomar cuidado. Ao testar _igualdade_, sempre usamos o operador ``==``. Em programação, é importante ler o sinal de ``=`` como "é" e o sinal ``==`` como "igual". Podemos querer vôos que partiram em um mês e em outro escolhido. Não há problema, usamos o sinal ``|``, a barra vertical, que deve ser lido como "ou".

## Básico do ``dplyr`` e de lógica

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

filter(flights, month == 11 | month == 12)
```

## Básico do ``dplyr`` e de lógica

Observe que o código _precisa_ estar assim, pois ``filter(flights, month == 11 | 12)`` é interpretado como um teste lógico. A firmativa ``11 | 12`` é lida como verdadeira, então recebe o valor lógico de ``TRUE``, que o R prontamente lê como $1$ e entende que você está se referindo ao mês 1, janeiro. Para evitar isso, podemos usar o operador ``%in%``.

```{r, echo=T, eval=T, results='asis', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
nov_dec <- filter(flights, month %in% c(11, 12))
```


## Básico do ``dplyr`` e de lógica

Podemos também usar o operador ``!``, que nota negação:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

filter(flights, !(arr_delay > 120 | dep_delay > 120))
```

## Básico do ``dplyr`` e de lógica

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

filter(flights, arr_delay <= 120, dep_delay <= 120)
```

## Arrumando dados com ``arrange()``

``arrange()`` funciona de maneira similar, mas ao invés de escolher pedaços dos dados, altera sua ordem. Alimentamos sempre um objeto ``data.frame`` e depois dizemos - em ordem - quais variáveis devem ser usadas para ordenação:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
arrange(flights, year, month, day)
```

## Arrumando dados com ``arrange()``

Podemos usar ``desc`` para ordem descendente:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
arrange(flights, desc(arr_delay))
```

## Selecionando colunas com ``select()``

É comum trabalhar com bases de dados que tenham centenas ou mesmo milhares de variáveis. Para isso podemos usar ``select()`` e simplificar a tarefa em mãos.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
# selecionando colunas por nome
select(flights, year, month, day)
```

## Selecionando colunas com ``select()``

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

# selecionando por grupo
select(flights, year:day)
```

## Selecionando colunas com ``select()``

Existem várias funções úteis que combinam com ``select()``:

* ``starts_with("abc")`` pega somente colunas com nomes que comecem com "abc"

* ``ends_with("xyz")`` faz o mesmo, mas para colunas que terminam da maneira entre parênteses

* ``contains("ijk")`` faz isso com colunas que tenham em qualquer parte de seus nomes o termo entre parênteses

* ``num_range("x", 1:3)`` seleciona as variáveis ``x1, ``x2``, ``x3``. Poderíamos alterar a amplitude dos números e do termo entre parênteses para nossas necessidades

* Para renomear variáveis usamos ``rename()``

## Selecionando colunas com ``select()``

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
rename(flights, tail_num = tailnum)
```

## Adicionando variáveis com ``mutate()``

É comum precisar _criar_ variáveis e podemos fazer isso comodamente com ``mutate()``, que sempre irá adicionar a variável que especificarmos ao final do ``data.frame``. Vamos gerar um objeto desssa classe, menor, e depois introduzir duas variáveis, ``gain`` que será a diferença dos atrasos de partida e chegada e ``speed``, a velocidade média do vôo.

## Adicionando variáveis com ``mutate()``

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
base <- select(flights,
 year:day,
 ends_with("delay"),
 distance,
 air_time)
mutate(base,
 gain = arr_delay - dep_delay,
 speed = distance / air_time * 60)
```

## Adicionando variáveis com ``mutate()``

Se você quer _somente_ as variáveis geradas, então use ``transmute()``:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
transmute(flights,
 gain = arr_delay - dep_delay,
 hours = air_time / 60)
```

Os mesmos truques que operadores que usamos para a calculadora do R também valem dentro das funções ``mutate()`` e ``transmute()``.

## Sumários com ``summarise()``

O último verbo importante da gramática de dados do ``dplyr`` é ``summarise()``. Ele essencialmente cria resumos do dataframe que estamos usando:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

## Sumários com ``summarise()``

Note que o argumetno ``na.rm`` da função ``mean()`` - que calcula médias - serve para fazer o R ignorar observações vazias ou faltantes, os ``NA``. Isso é importante para a função ``mean()``, que retorna erro quando lida com ``NA``.

## Sumários com ``summarise()``

A função ``summarise()`` fica excepcionalmente poderosa quando combinada com ``group_by()``, que agrupa os dados.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
summarise(group_by(flights, year, month, day), delay = mean(dep_delay, na.rm = TRUE))
```

# Combinando operações múltiplas com o Pipe
## Combinando operações múltiplas com o Pipe

Imagine que estamos procurando uma relação entre algumas variáveis dos dados:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
por_distancia <- group_by(flights, dest)
atraso <- summarize(por_distancia,
 count = n(), dist = mean(distance, na.rm = TRUE),
 delay = mean(arr_delay, na.rm = TRUE))
delay <- filter(atraso, count > 20, dest != "HNL")
```


## Combinando operações múltiplas com o Pipe

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
 geom_point(aes(size = count), alpha = 1/3) +
 geom_smooth(se = FALSE)
```


## Combinando operações múltiplas com o Pipe

Fizemos uma sequência de passos grande e facilmente poderíamos ter errado algo no caminho. Além de que, qualquer alteração em uma linha de código provavelmente vai exigir que se altere em outras. Resolvemos isso com o operador ``%>%``, o Pipe. Entenda ele como um cano, que "engata" funções.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
atrasos <- flights %>%
 group_by(dest) %>%
 summarize(count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE)) %>%
 filter(count > 20, dest != "HNL")
 
```


## Combinando operações múltiplas com o Pipe

Temos um código muito mais legível e rápido. Note que o pipe deve ser posto sempre como o sinal positivo em gráficos do ``ggplot2``. Voltando aos dados, podemos querer cruzar atrasos com números de vôos no dia.

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
nao_cancelados <- flights %>%
 filter(!is.na(dep_delay), !is.na(arr_delay))
atrasos <- nao_cancelados %>%
 group_by(tailnum) %>%
 summarize(delay = mean(arr_delay, na.rm = TRUE),
 n = n())
ggplot(data = atrasos, mapping = aes(x = n, y = delay)) +
 geom_point(alpha = 1/10)
```


## Combinando operações múltiplas com o Pipe

Observe que talvez não seja muito interessante manter na nossa análise exploratória dados de dias com pouquíssimos vôos - já que tendem a ser anômalos. Com um pipe, isso vira uma breve alteração no código

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}
atrasos %>%
 filter(n > 25) %>%
 ggplot(mapping = aes(x = n, y = delay)) +
 geom_point(alpha = 1/10)
```

# Sumários
## Sumários

Algumas funções são muito úteis para sumários:

* ``IQR()`` dá o intervalor interquartil

* ``min()`` e ``max()`` dão os valores mínimo e máximo da variável

* ``sd()`` dá o desvio-padrão

* ``meadian()`` dá a mediana

* ``mad()`` dá o desvio absoluto médio

* ``var()`` dá a variância

# Desagrupar dados
## Desagrupar dados

Por fim, podemos querer _desagrupar_ dados que vieram agrupados por ``group_by()``. Basta usar ``ungroup()``:

```{r, echo=T, eval=T, results='markup', fig.cap='', fig.width=8, fig.height=4, fig.align='center', out.width=".7\\linewidth", warning=FALSE, message=FALSE, size='tiny'}

diario <- group_by(flights, year, month, day)
diario %>%
 ungroup() %>% 
  summarise(flights = n()) 
```
